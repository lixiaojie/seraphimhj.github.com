--- 
status: publish
layout: post
title: !binary |
  56ys5LiA5Zue4oCU4oCU5Zu+6K665Z+656GA

meta: 
  _jd_wp_twitter: !binary |
    UG9zdCBFZGl0ZWQ6IOesrOS4gOWbnuKAlOKAlOWbvuiuuuWfuuehgCBodHRw
    Oi8vaHVhbmdqaWFuLmluZm8vMjQ5L+esrOS4gOWbnuKAlOKAlOWbvuiuuuWf
    uuehgC8=

  _wp_jd_bitly: ""
  _wp_jd_clig: ""
  _wp_jd_wp: !binary |
    aHR0cDovL2h1YW5namlhbi5pbmZvLzI0OS/nrKzkuIDlm57igJTigJTlm77o
    rrrln7rnoYAv

  _edit_last: "1"
  _wp_old_slug: ""
  _wp_jd_yourls: ""
  _jd_post_meta_fixed: "true"
  _wp_jd_target: ""
  _wp_jd_url: ""
  _jd_twitter: ""
  _jd_tweet_this: "yes"
tags: 
- data struct
- graph
- Research
published: true
type: post
---
今天看了‘CLRS‘中的图算法一章，记点要点总结下：
图的两种表达方式：邻接表和邻接矩阵。
邻接表用于稀疏矩阵，由vertex的数组组成，指向与它相邻的可达节点（带有指针，指向下一个邻接的可达节点），可以在节点中再存储权值、计数信息等等；
邻接矩阵用于稠密矩阵，或是需要经常性或快速地判断两个顶点之间是否有边的情况，可直接在二维数组内存储权值等信息。
<!--more-->

广度优先搜索：队列实现，将所有节点“漂白”，从顶点s出发，染灰，入队列Q，设置d[s]=0，前驱节点P[s]=NULL。循环不变式：队列Q不为空，节点u出队，遍历所有与它相邻的节点v，若为白，则染灰，入队列，d[v]=d[u]+1,P[v]=u，当遍历结束，u染黑，继续循环。
深度优先搜索：堆栈或递归实现，所有节点“漂白”，遍历白色顶点，染灰，记录发现时间，遍历它的邻接白节点，递归函数调用，DFS该节点，遍历完成后染黑，记录完成时间。
拓扑排序：DFS后对完成时间降序排序。是一个有向无回路图，前面节点为后面节点的父节点或无关节点。
强连通分量：第一次DFS_main，对第一次DFS_main的完成时间升序排顶点，将G转置为G<sup>T</sup>，依次进行DFS_main，每次DFS遍历完成的输出为强连通分量，并设置为visited。
在网上搜了一段代码，对今天看的内容都有涵盖，从抽象到具体地理解下，

//邻接表表示的图的深度优先搜索和广度优先搜索程序
#include
#define maxvertexnum 100
#define queuesize 100
#define null 0

typedef struct{
int front,rear,count,data[queuesize];
}cirqueue;//循环队列结构定义

typedef int vertextype;//为了简单，设图中结点的数据为整型
typedef struct node{
int adjvex;//存放邻接点序号
struct node *next;//指向下一个边结点
}edgenode;//图的邻接表的边结点定义

typedef struct vnode{
vertextype vertex;//顶点数据域
edgenode *firstedge;//指向第一个边结点
}vertexnode;//图的邻接表表示的顶点结点定义

typedef vertexnode adjlist[maxvertexnum];//用向量定义图的邻接表表示的顶点表

typedef struct{
adjlist adjlist;
int n;//图的顶点数
int e;//图的边数
}algraph;//定义图的邻接表

typedef enum{FALSE,TRUE}boolean;
boolean visited[maxvertexnum];//保存访问信息的布尔向量

main()//主函数
{//建立图g，并进行深度优先搜索和广度优先搜索
algraph *g;
g=(algraph*)malloc(sizeof(algraph));//申请图g的邻接表空间
createalgraph(g);//建立图g的邻接表表示
printf("the dfs is:");/
dfstraverse(g);//对图g进行深度优先搜索，并打印搜索序列
printf("the bfs is:");
bfstraverse(g);//对图g进行广度优先搜索，并打印搜索序列
}

createalgraph(algraph *g)
{//建立图g的邻接表表示
int i,j,k;
int flag;
edgenode *s;
printf("\ncreat:\n")//选择建立有向图或无向图
printf("digraph--0\n");
printf("undigraph--1\n");
scanf("%d",&amp;flag);
printf("input n,e\n");
scanf("%d%d",&amp;g-&gt;n,&amp;g-&gt;e);//输入图g的顶点数和边数
printf("input nodes:\n");
for(i=0;in;i++){//构造一个只含n个顶点，边数为0的图
scanf("%d",&amp;(g-&gt;adjlist[i].vertex));
//输入顶点的数据域（为了简单起见，输入为整数）
g-&gt;adjlist[i].firstedge=null;//将顶点结点的firstedge域置为空
}//end for
for(k=0;ke;k++){
printf("input i,j(0~n-1):\n");
scanf("%d%d",&amp;i,&amp;j);//输入对应于一条边的顶点序号序偶对，要求顶点序号为0~n-1
s=(edgenode *)malloc(sizeof(edgenode));//申请一个边结点*s
s-&gt;adjvex=j;//将序号j放入边结点*s的adjvex域
s-&gt;next=g-&gt;adjlist[i].firstedge;
//将边结点*s作为第一个邻接点插入到序号为i的顶点的边表中
g-&gt;adjlist[i].firstedge=s;
if (flag){//若要建立无向图
s=(edgenode *)malloc(sizeof(edgenode));申请一个边结点*s
s-&gt;adjvex=i;//将序号i放入边结点*s的adjvex域
s-&gt;next=g-&gt;adjlist[j].firstedge;
//将边结点*s作为第一个邻接点插入到序号为j的顶点的边表中
g-&gt;adjlist[j].firstedge=s;
}//end of if
}//end of for
}//end of creatalgraph

dfs(algraph *g,int i)
{//对图g进行以序号为i的顶点作为出发点深度优先搜索
edgenode *p;
printf("visit vertex:%d",g-&gt;adjlist[i].vertex);//打印序号为i的顶点信息
visited[i]=TRUE;//将序号为i的顶点设置已访问过标记
p=g-&gt;adjlist[i].firstedge;//设置寻找序号为i的第一个未访问过邻接点的扫描指针
while(p){
if (!visited[p-&gt;adjvex])//若*p边结点对应顶点（假设序号为j）未访问过
dfs(g,p-&gt;adjvex);//对图g进行以序号为j的顶点作为出发点进行深度优先搜索
p=p-&gt;next;//p顺着边表next指针，往后继续寻找
}//end of while
}//end of dfs

dfstraverse(algraph *g)
{//对以邻接表表示的图g进行深度优先搜索
int i;
for(i=0;in;i++)//将图g的所有顶点设置未访问过标记
visited[i]=FALSE;
for(i=0;in;i++)//对图g调用dfs函数进行深度优先搜索
if(!visited[i])
dfs(g,i);
printf("\n");
}//end of dfstraverse

bfs(algraph *g,int k)
{//对图g进行以序号为k的顶点作为出发点广度优先搜索
int i,j;
cirqueue *q;//设置循环队列指针
edgenode *p;
q=(cirqueue *)malloc(sizeof(cirqueue));//申请循环队列空间
q-&gt;rear=q-&gt;front=q-&gt;count=0;//将循环队列置为空队
printf("visit vertex:%d",g-&gt;adjlist[k].vertex);
visited[k]=TRUE;//将序号为k的顶点设置为已访问过
q-&gt;data[q-&gt;rear]=k;q-&gt;rear=(q-&gt;rear+1)%queuesize;q-&gt;count++;//将顶点序号k入队
while(q-&gt;count){//当队列非空时做以下操作
i=q-&gt;data[q-&gt;front];q-&gt;front=(q-&gt;front+1)%queuesize;q-&gt;count--;//将队首元素i出队
p=g-&gt;adjlist[i].firstedge;//设置寻找序号为i顶点的未访问过邻接点的扫描指针p
while (p){//当*p不为空时，做以下操作
if(!visited[p-&gt;adjvex]){//若*p边结点对应顶点（假设序号为j）未访问过
printf("visit vertex:%d",g-&gt;adjlist[p-&gt;adjvex].vertex);
//访问序号为j的顶点
visited[p-&gt;adjvex]=TRUE;//设置已访问过标记
q-&gt;data[q-&gt;rear]=p-&gt;adjvex;q-&gt;rear=(q-&gt;rear+1)%queuesize;q-&gt;count++;
//将序号为j的顶点入队
}//end of if
p=p-&gt;next;//p顺着边表next指针，往后继续寻找
}//end of while
}//end of while
}//end of bfs

bfstraverse(algraph *g)
{//对以邻接表表示的图g进行广度优先搜索
int i;
for(i=0;in;i++)//将图g的所有顶点设置未访问过标记
visited[i]=FALSE;
for(i=0;in;i++)//对图g调用bfs函数进行广度优先搜索
if(!visited[i])
bfs(g,i);
printf("\n");
}
