--- 
status: publish
layout: post
title: !binary |
  56ys5LiA5Zue4oCU4oCU5Zu+6K665Z+656GA

meta: 
  _jd_wp_twitter: !binary |
    UG9zdCBFZGl0ZWQ6IOesrOS4gOWbnuKAlOKAlOWbvuiuuuWfuuehgCBodHRw
    Oi8vaHVhbmdqaWFuLmluZm8vMjQ5L+esrOS4gOWbnuKAlOKAlOWbvuiuuuWf
    uuehgC8=

  _wp_jd_bitly: ""
  _wp_jd_clig: ""
  _wp_jd_wp: !binary |
    aHR0cDovL2h1YW5namlhbi5pbmZvLzI0OS/nrKzkuIDlm57igJTigJTlm77o
    rrrln7rnoYAv

  _edit_last: "1"
  _wp_old_slug: ""
  _wp_jd_yourls: ""
  _jd_post_meta_fixed: "true"
  _wp_jd_target: ""
  _wp_jd_url: ""
  _jd_twitter: ""
  _jd_tweet_this: "yes"
tags: 
- data struct
- graph
- Research
published: true
type: post
---
今天看了‘CLRS‘中的图算法一章，记点要点总结下：</br>
图的两种表达方式：邻接表和邻接矩阵。</br>
邻接表用于稀疏矩阵，由vertex的数组组成，指向与它相邻的可达节点（带有指针，指向下一个邻接的可达节点），可以在节点中再存储权值、计数信息等等；</br>
邻接矩阵用于稠密矩阵，或是需要经常性或快速地判断两个顶点之间是否有边的情况，可直接在二维数组内存储权值等信息。</br>
<!--more--></br>
</br>
广度优先搜索：队列实现，将所有节点“漂白”，从顶点s出发，染灰，入队列Q，设置d[s]=0，前驱节点P[s]=NULL。循环不变式：队列Q不为空，节点u出队，遍历所有与它相邻的节点v，若为白，则染灰，入队列，d[v]=d[u]+1,P[v]=u，当遍历结束，u染黑，继续循环。</br>
深度优先搜索：堆栈或递归实现，所有节点“漂白”，遍历白色顶点，染灰，记录发现时间，遍历它的邻接白节点，递归函数调用，DFS该节点，遍历完成后染黑，记录完成时间。</br>
拓扑排序：DFS后对完成时间降序排序。是一个有向无回路图，前面节点为后面节点的父节点或无关节点。</br>
强连通分量：第一次DFS_main，对第一次DFS_main的完成时间升序排顶点，将G转置为G<sup>T</sup>，依次进行DFS_main，每次DFS遍历完成的输出为强连通分量，并设置为visited。</br>
在网上搜了一段代码，对今天看的内容都有涵盖，从抽象到具体地理解下，</br>
</br>
//邻接表表示的图的深度优先搜索和广度优先搜索程序</br>
#include</br>
#define maxvertexnum 100</br>
#define queuesize 100</br>
#define null 0</br>
</br>
typedef struct{</br>
int front,rear,count,data[queuesize];</br>
}cirqueue;//循环队列结构定义</br>
</br>
typedef int vertextype;//为了简单，设图中结点的数据为整型</br>
typedef struct node{</br>
int adjvex;//存放邻接点序号</br>
struct node *next;//指向下一个边结点</br>
}edgenode;//图的邻接表的边结点定义</br>
</br>
typedef struct vnode{</br>
vertextype vertex;//顶点数据域</br>
edgenode *firstedge;//指向第一个边结点</br>
}vertexnode;//图的邻接表表示的顶点结点定义</br>
</br>
typedef vertexnode adjlist[maxvertexnum];//用向量定义图的邻接表表示的顶点表</br>
</br>
typedef struct{</br>
adjlist adjlist;</br>
int n;//图的顶点数</br>
int e;//图的边数</br>
}algraph;//定义图的邻接表</br>
</br>
typedef enum{FALSE,TRUE}boolean;</br>
boolean visited[maxvertexnum];//保存访问信息的布尔向量</br>
</br>
main()//主函数</br>
{//建立图g，并进行深度优先搜索和广度优先搜索</br>
algraph *g;</br>
g=(algraph*)malloc(sizeof(algraph));//申请图g的邻接表空间</br>
createalgraph(g);//建立图g的邻接表表示</br>
printf("the dfs is:");/</br>
dfstraverse(g);//对图g进行深度优先搜索，并打印搜索序列</br>
printf("the bfs is:");</br>
bfstraverse(g);//对图g进行广度优先搜索，并打印搜索序列</br>
}</br>
</br>
createalgraph(algraph *g)</br>
{//建立图g的邻接表表示</br>
int i,j,k;</br>
int flag;</br>
edgenode *s;</br>
printf("\ncreat:\n")//选择建立有向图或无向图</br>
printf("digraph--0\n");</br>
printf("undigraph--1\n");</br>
scanf("%d",&amp;flag);</br>
printf("input n,e\n");</br>
scanf("%d%d",&amp;g-&gt;n,&amp;g-&gt;e);//输入图g的顶点数和边数</br>
printf("input nodes:\n");</br>
for(i=0;in;i++){//构造一个只含n个顶点，边数为0的图</br>
scanf("%d",&amp;(g-&gt;adjlist[i].vertex));</br>
//输入顶点的数据域（为了简单起见，输入为整数）</br>
g-&gt;adjlist[i].firstedge=null;//将顶点结点的firstedge域置为空</br>
}//end for</br>
for(k=0;ke;k++){</br>
printf("input i,j(0~n-1):\n");</br>
scanf("%d%d",&amp;i,&amp;j);//输入对应于一条边的顶点序号序偶对，要求顶点序号为0~n-1</br>
s=(edgenode *)malloc(sizeof(edgenode));//申请一个边结点*s</br>
s-&gt;adjvex=j;//将序号j放入边结点*s的adjvex域</br>
s-&gt;next=g-&gt;adjlist[i].firstedge;</br>
//将边结点*s作为第一个邻接点插入到序号为i的顶点的边表中</br>
g-&gt;adjlist[i].firstedge=s;</br>
if (flag){//若要建立无向图</br>
s=(edgenode *)malloc(sizeof(edgenode));申请一个边结点*s</br>
s-&gt;adjvex=i;//将序号i放入边结点*s的adjvex域</br>
s-&gt;next=g-&gt;adjlist[j].firstedge;</br>
//将边结点*s作为第一个邻接点插入到序号为j的顶点的边表中</br>
g-&gt;adjlist[j].firstedge=s;</br>
}//end of if</br>
}//end of for</br>
}//end of creatalgraph</br>
</br>
dfs(algraph *g,int i)</br>
{//对图g进行以序号为i的顶点作为出发点深度优先搜索</br>
edgenode *p;</br>
printf("visit vertex:%d",g-&gt;adjlist[i].vertex);//打印序号为i的顶点信息</br>
visited[i]=TRUE;//将序号为i的顶点设置已访问过标记</br>
p=g-&gt;adjlist[i].firstedge;//设置寻找序号为i的第一个未访问过邻接点的扫描指针</br>
while(p){</br>
if (!visited[p-&gt;adjvex])//若*p边结点对应顶点（假设序号为j）未访问过</br>
dfs(g,p-&gt;adjvex);//对图g进行以序号为j的顶点作为出发点进行深度优先搜索</br>
p=p-&gt;next;//p顺着边表next指针，往后继续寻找</br>
}//end of while</br>
}//end of dfs</br>
</br>
dfstraverse(algraph *g)</br>
{//对以邻接表表示的图g进行深度优先搜索</br>
int i;</br>
for(i=0;in;i++)//将图g的所有顶点设置未访问过标记</br>
visited[i]=FALSE;</br>
for(i=0;in;i++)//对图g调用dfs函数进行深度优先搜索</br>
if(!visited[i])</br>
dfs(g,i);</br>
printf("\n");</br>
}//end of dfstraverse</br>
</br>
bfs(algraph *g,int k)</br>
{//对图g进行以序号为k的顶点作为出发点广度优先搜索</br>
int i,j;</br>
cirqueue *q;//设置循环队列指针</br>
edgenode *p;</br>
q=(cirqueue *)malloc(sizeof(cirqueue));//申请循环队列空间</br>
q-&gt;rear=q-&gt;front=q-&gt;count=0;//将循环队列置为空队</br>
printf("visit vertex:%d",g-&gt;adjlist[k].vertex);</br>
visited[k]=TRUE;//将序号为k的顶点设置为已访问过</br>
q-&gt;data[q-&gt;rear]=k;q-&gt;rear=(q-&gt;rear+1)%queuesize;q-&gt;count++;//将顶点序号k入队</br>
while(q-&gt;count){//当队列非空时做以下操作</br>
i=q-&gt;data[q-&gt;front];q-&gt;front=(q-&gt;front+1)%queuesize;q-&gt;count--;//将队首元素i出队</br>
p=g-&gt;adjlist[i].firstedge;//设置寻找序号为i顶点的未访问过邻接点的扫描指针p</br>
while (p){//当*p不为空时，做以下操作</br>
if(!visited[p-&gt;adjvex]){//若*p边结点对应顶点（假设序号为j）未访问过</br>
printf("visit vertex:%d",g-&gt;adjlist[p-&gt;adjvex].vertex);</br>
//访问序号为j的顶点</br>
visited[p-&gt;adjvex]=TRUE;//设置已访问过标记</br>
q-&gt;data[q-&gt;rear]=p-&gt;adjvex;q-&gt;rear=(q-&gt;rear+1)%queuesize;q-&gt;count++;</br>
//将序号为j的顶点入队</br>
}//end of if</br>
p=p-&gt;next;//p顺着边表next指针，往后继续寻找</br>
}//end of while</br>
}//end of while</br>
}//end of bfs</br>
</br>
bfstraverse(algraph *g)</br>
{//对以邻接表表示的图g进行广度优先搜索</br>
int i;</br>
for(i=0;in;i++)//将图g的所有顶点设置未访问过标记</br>
visited[i]=FALSE;</br>
for(i=0;in;i++)//对图g调用bfs函数进行广度优先搜索</br>
if(!visited[i])</br>
bfs(g,i);</br>
printf("\n");</br>
}
