--- 
status: publish
layout: post
title: !binary |
  5aSn5a625LiA6LW355SoZ3Rr57yW56iLMw==

meta: 
  _jd_wp_twitter: "Post Edited: \xE5\xA4\xA7\xE5\xAE\xB6\xE4\xB8\x80\xE8\xB5\xB7\xE7\x94\xA8gtk\xE7\xBC\x96\xE7\xA8\x8B3 http://huangjian.info/186/gtk_program_3_makefile/"
  _wp_jd_bitly: ""
  _wp_jd_clig: ""
  _wp_jd_wp: http://huangjian.info/186/gtk_program_3_makefile/
  _edit_last: "1"
  _wp_old_slug: ""
  _wp_jd_yourls: ""
  _jd_post_meta_fixed: "true"
  _wp_jd_target: http://huangjian.info/186/gtk_program_3_makefile/
  _wp_jd_url: ""
  _jd_tweet_this: "yes"
  _jd_twitter: ""
tags: 
- gtk
- Program
- Technics
published: true
type: post
---
<ul>
	<li>5、初步使用Makefile</li>
</ul>
<p align="left">上回说道，咱们使用GTK创建了一个能够截获事件的GTK程序，本节将简单地介绍一下如何使用Makefile来组织我们的源程序，使用Makefile是基于如下几个原因：</p>

<ul>
	<li>能实现从无限简单到无穷复杂的软件工程组织</li>
	<li>能方便地与众多的Linux命令与实用程序集成，当然也包括Vim与emacs</li>
	<li>还有很多，就留给读者自己探索吧…</li>
</ul>
<!--more-->
<p align="left">笔者在这里介绍Makefile的主要目的是想让大家知道Linux下有这样一个工具，使用它确实很方便，并且希望大家在有需要的时候能够想到它。</p>
<p align="left">总的来说，Makefile是使用一系列的依赖关系和时间值，来决定是否对一个目标进行重构建；不废话了，来看看我们的Makefile文件长什么样：</p>

<table width="100%" border="1" cellspacing="1" cellpadding="0">
<tbody>
<tr>
<td>
<p align="center">Makefile</p>
<p align="left">注意：Makefile 文件如果从网页上直接拷贝，往往不能成功正常使用，请从下边的附件中下载可用的文件。</p>
</td>
</tr>
<tr>
<td>
<p align="left">CC=gcc
PROG_NAME=hello_dubuntu2
INCS=
SRCS=hello_dubuntu2.c
#从xx.c 文件得到 xx.o 文件
OBJS=${SRCS:.c=.o}#编译GTK程序时要用到的库
LIBS=gtk+-2.0
#—- 用户修改区域 结束</p>
<p align="left"># -O2
CFLAGS=`pkg-config –cflags ${LIBS}` -g -Wall
LDFLAGS=`pkg-config –libs ${LIBS}`   -g -Wall</p>
<p align="left">all: ${PROG_NAME}</p>
<p align="left">${PROG_NAME}:${OBJS}
${CC} -o ${PROG_NAME} ${OBJS} ${LDFLAGS}
#注意：上边”${CC}” 的前边有一个TAB键，而不是空格</p>
<p align="left">#如果有头文件进行修改，则自动编译源文件
${OBJS}:${INCS}</p>
<p align="left">.c.o:
${CC} -c $&lt;  ${CFLAGS}</p>
<p align="left">clean:
rm -f *.o  ${PROG_NAME}</p>
<p align="left">rebuild: clean all</p>
</td>
</tr>
<tr>
<td>
<p align="left">编译：将此Makefile文件与上一节的 hello_dubuntu2.c 文件放在同一个文件夹下，然后运行如下命令即可编译出 hello_dubuntu2 可执行文件</p>
</td>
</tr>
</tbody>
</table>
<p align="left">程序注释：
1）刚开始的几行定义了几个变量，比如用CC来代替真正的 gcc 编译器，这样当想换别的编译器来编译我们的程序时直接改变CC变量的值就OK了。其它的：</p>

<ul>
	<li>CC 指代用来编译程序的编译器，这里使用 gcc</li>
	<li>RPOG_NAME 指代最终要生成的可执行文件名，需手工填入</li>
	<li>INCS 指代工程文件中所自定义的所有头文件，需手工填入</li>
	<li>SRCS 指代所有使用到的源文件，需手工填入</li>
	<li>OBJS 是通过 .c 文件得到的 .o 文件，因为每个 .c 文件都将编译生成一个对应的 .o 文件，自动生成</li>
	<li>LIBS 用来指代编译GTK程序时需要使用到的GTK相关库，一般使用默认的 gtk+-2.0 即可，需手工填入</li>
	<li>CFLAGS 用来指代编译程序时使用到的一些编译选项， -g 表示生成调试信息以供GDB使用，-Wall表示生成编译时的警告信息（W表示Warning，all 表示全部)</li>
	<li>LDFLAGS 用来指代进行程序连接时使用到的一些选项</li>
</ul>
<p align="left">以上这些变量，将在Makefile的剩余部分使用 ${xxx} 的形式进行引用。</p>
<p align="left">2）关于“目标”：“依赖关系”
从“all: ${PROG_NAME}”这一句开始，Makefile就开始使用 目标：依赖 的关系来处理真正的程序编译了；而它们下边以 TAB 键开始的行就是满足依赖关系后要运行的程序（注意：是TAB键，不是空格）。具体笔者就不详细描述了，有兴趣的读者可以参考下边推荐的教程。</p>
<p align="left">3）关于 “.c.o:” 语句：
这句话的意思就是说，当遇到一个 .c 文件，那么使用它下边的命令“         ${CC} -c $&lt;  ${CFLAGS}” 将 .c 文件编译为 .o 文件；命令中 $&lt; 用来代替对应的 .c 文件的文件名。</p>
<p align="left">4）关于”clean” 和 “rebuild”：
这两个者伪目标，必须使用 “make clean” 或 “make rebuild” 来引用，”make clean” 用于删除生成的 .o 目标文件和可执行文件； “make rebuild” 用于对整个工程进行重构建。</p>
<p align="left">5）小技巧：
在Vim中，先按 ESC 键回到命令模式，再按 “:make” 命令即可对Makefile工程进行编译，如果有编译错误，那么Vim会自动定位到产生错误的源程序所对应的代码行，非常利于程序的修改，使用命 令”:cn” 和 “cp” 还可以定位到“下一个错误”与“上一个错误”。</p>
<p align="left">当然，更高级的用法是，使用 autoconf, automake 等工具来自动生成一个符合GNU标准的工程，然后通过它们来自动生成 Makefile 文件，这样做更佳方便快捷，自动化程度更高，并且能够使程序更具有可移值性，本文将在后续章节开辟专门一节来进行详细描述。</p>
<p align="left">最后，推荐一篇好教程：<a href="http://www.chinaunix.net/jh/23/408225.html" target="_blank">跟我一起写Makefile</a></p>
