--- 
status: publish
layout: post
title: !binary |
  5aS05paH5Lu255qE6Zeu6aKY
tags: 
- c++
- head file
- Technics
published: true
type: post
---
最近，在华为的实习项目需要对上下行传输链路（两个工程）进行合并，这就涉及到许多头文件，重名函数，变量，结构体，宏定义，枚举类型的相互干扰。如何解除这些干扰，是一个问题。这里给出的一个办法是进行上下行类封装，随后，引出新的问题：C语言改写成C++类代码，于是类中的成员函数初始化，需要在构造函数中完成，公共部分需要拿到类外。头文件包含复杂，由于上下行重名的问题，容易发生重定义。</br>
</br>
于是，上网查询了一些头文件的使用事项，记录之。</br>
</br>
<!--more--></br>
</br>
<strong><span style="color: #ff0000;">First One</span></strong></br>
</br>
<strong>C++中头文件相互包含的几点问题</strong></br>
一、类嵌套的疑问</br>
</br>
C++头文件重复包含实在是一个令人头痛的问题，前一段时间在做一个简单的数据结构演示程序的时候，不只一次的遇到这种问题。假设我们有两个类A和B，分别定义在各自的有文件A.h和B.h中，但是在A中要用到B，B中也要用到A，但是这样的写法当然是错误的：</br>
class B;</br>
</br>
class A</br>
{</br>
public:</br>
B b;</br>
};</br>
</br>
class B</br>
{</br>
public:</br>
A a;</br>
};</br>
因为在A对象中要开辟一块属于B的空间，而B中又有A的空间，是一个逻辑错误，无法实现的。在这里我们只需要把其中的一个A类中的B类型成员改成指针形式就可以避免这个无限延伸的怪圈了。为什么要更改A而不是B？因为就算你在B中做了类似的动作，也仍然会编译错误，表面上这仅仅上一个先后顺序的问题。</br>
为什么会这样呢？因为C++编译器自上而下编译源文件的时候，对每一个数据的定义，总是需要知道定义的数据的类型的大小。在预先声明语句class B;之后，编译器已经知道B是一个类，但是其中的数据却是未知的，因此B类型的大小也不知道。这样就造成了编译失败，VC++6.0下会得到如下编译错误：</br>
error C2079: 'b' uses undefined class 'B'</br>
将A中的b更改为B指针类型之后，由于在特定的平台上，指针所占的空间是一定的（在Win32平台上是4字节），这样可以通过编译。</br>
</br>
二、不同头文件中的类的嵌套</br>
</br>
在实际编程中，不同的类一般是放在不同的相互独立的头文件中的，这样两个类在相互引用时又会有不一样的问题。重复编译是问题出现的根本原因。为了保证头文件仅被编译一次，在C++中常用的办法是使用条件编译命令。在头文件中我们常常会看到以下语句段（以VC++6.0自动生成的头文件为例）：</br>
</br>
#if !defined(AFX_STACK_H__1F725F28_AF9E_4BEB_8560_67813900AE6B__INCLUDED_)</br>
#define AFX_STACK_H__1F725F28_AF9E_4BEB_8560_67813900AE6B__INCLUDED_</br>
//很多语句……</br>
#endif</br>
</br>
其中首句#if !defined也经常做#ifndef，作用相同。意思是如果没有定义过这个宏，那么就定义它，然后执行直到#endif的所有语句。如果下次在与要这段代码，由于已经定义了那个宏，因此重复的代码不会被再次执行。这实在是一个巧妙而高效的办法。在高版本的VC++上，还可以使用这个命令来代替以上的所有：</br>
#pragma once</br>
它的意思是，本文件内的代码只被使用一次。</br>
</br>
但是不要以为使用了这种机制就全部搞定了，比如在以下的代码中：</br>
</br>
//文件A.h中的代码</br>
#pragma once</br>
</br>
#include "B.h"</br>
</br>
class A</br>
{</br>
public:</br>
B* b;</br>
};</br>
</br>
//文件B.h中的代码</br>
#pragma once</br>
</br>
#include "A.h"</br>
</br>
class B</br>
{</br>
public:</br>
A* a;</br>
};</br>
</br>
这里两者都使用了指针成员，因此嵌套本身不会有什么问题，在主函数前面使用#include "A.h"之后，主要编译错误如下：</br>
error C2501: 'A' : missing storage-class or type specifiers</br>
仍然是类型不能找到的错误。其实这里仍然需要前置声明。分别添加前置声明之后，可以成功编译了。代码形式如下：</br>
</br>
//文件A.h中的代码</br>
#pragma once</br>
</br>
#include "B.h"</br>
</br>
class B;</br>
</br>
class A</br>
{</br>
public:</br>
B* b;</br>
};</br>
</br>
//文件B.h中的代码</br>
#pragma once</br>
</br>
#include "A.h"</br>
</br>
class B;</br>
</br>
class B</br>
{</br>
public:</br>
A* a;</br>
};</br>
</br>
这样至少可以说明，头文件包含代替不了前置声明。有的时候只能依靠前置声明来解决问题。我们还要思考一下，有了前置声明的时候头文件包含还是必要的吗？我们尝试去掉A.h和B.h中的#include行，发现没有出现新的错误。那么究竟什么时候需要前置声明，什么时候需要头文件包含呢？</br>
</br>
三、两点原则</br>
</br>
头文件包含其实是一想很烦琐的工作，不但我们看着累，编译器编译的时候也很累，再加上头文件中常常出现的宏定义。感觉各种宏定义的展开是非常耗时间的，远不如自定义函数来得速度。我仅就不同头文件、源文件间的句则结构问题提出两点原则，仅供参考：</br>
</br>
第一个原则应该是，如果可以不包含头文件，那就不要包含了。这时候前置声明可以解决问题。如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了。因为指针这一数据类型的大小是特定的，编译器可以获知。</br>
</br>
第二个原则应该是，尽量在CPP文件中包含头文件，而非在头文件中。假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类B的前置声明并便宜成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分（CPP文件）包含类B的头文件而非声明部分(H文件)。</br>
</br>
<span style="color: #ff0000;"><strong><span style="color: #ff0000;">Second One</span></strong></span></br>
<strong>头文件包含问题</strong></br>
C++中基础类互相引用带来的问题</br>
在一些大的工程中，可能会包含几十个基础类，免不了之间会互相引用 ( 不满足继承关系，而是组合关系 ) 。也就是需要互相声明。好了，这时候会带来一些混乱。如果处理得不好，会搞得一团糟，根据我的经验，简单谈谈自已的处理办法：</br>
</br>
编码时，我们一般会尽量避免 include 头文件，而是采用声明 class XXX 。 但有时候还是必须用 Include 头文件，那么，两者的划分在于什么呢？</br>
</br>
应该是很明确的，但书上好像都少有提及。</br>
</br>
首先：</br>
我们要明白为什么要用声明取代头文件包含：对了，是为了避免无必要的重编译 ( 在头文件发生变更时 ) 。 工程较大，低速机，或基础类经常变更 ( 不合理的设计吧 ) ，编译速度还是会在意的， 另外，更为重要的是，采用声明可降低代码 (class) 之间的藕合度，这也是面向对象设计的一大原则。</br>
</br>
二：一般原则：</br>
a. 头文件中尽量少 include, 如果可以简单申明 class clsOld; 解决，那最好。减少没有必要的 include；</br>
b. 实现文件中也要尽量少 include, 不要 include 没有用到的头文件。</br>
</br>
三：那什么时候可以只是简单声明 class clsOld 呢？</br>
简单的说：不需要知道 clsOld 的内存布局的用法都可以 ( 静态成员除外 ) ，也就是讲如果是指针或引用方式的 都行。</br>
比如：</br>
clsOld * m_pOld; // 指针占 4 个字节长</br>
clsOld &amp; test(clsOld * pOld) {return *pOld};</br>
一切 OK 。</br>
</br>
四：什么时候不能简单声明 class clsOld ，必须 include 呢？</br>
不满足三的情况下：</br>
比如：</br>
clsOld m_Objold; // 不知道占据大小，必须要通过它的具体声明来计算</br>
原因很简单，想想你要计算 sizeof(classNew) ，但连 clsOld 的 size 都不知道，编译器显然会无能为力。</br>
</br>
特殊情况：</br>
int test() { return clsOld::m_sInt;}</br>
静态成员调用，想来应该是不需要知道内存布局的，但因为需要知道 m_sInt 是属于 clsOld 命名空间 的，如果只声明 class xxx 显然是不足以说明的，所以必须包含头文件。</br>
</br>
综上所述，我有以下几点建议：</br>
1 ：如果有共同相关依赖 ( 必须 include) 的类，比如 A,B 都依赖 D 可以放在一起，然后直接 Include "d" 类的使用者只需关心与本类暴露出的相关类型，内部用到的类型不用去管 ( 不用自已去 include d) 。这样 给出的 class ，调用者才更好用 ( 不用去看代码查找，是不是还需要包含其它头文件 ) 。</br>
</br>
2 ：如果 A 类依赖 D B 类不依赖 D ，可以把它们分开两个头文件。各自 Include 。这样可避免当 D 发生变化时， 避免不必要重编译。</br>
</br>
3 ：类中尽量采用指针或引用方式调用其它类，这样就可以只声明 class xxx 了。并且这也符合资源最优 利用，更利于使用多态。</br>
</br>
/--------------------------------------------------/////////////////////////////////////////////////////////////////////////////</br>
</br>
对于VC++中的头文件包含值得注意的一点</br>
今天用VC++编译我这昨天写的代码时发现总是通不过，看到大部分的错误都是与一个类的定义有关。</br>
</br>
明明我已经在这个类中定义了一个成员变量，可编译器偏要说那个变量不是这个类的成员。没办法，找了半天原因还是没有头绪。再三地确认不是我C++的语法错误之后。我开始怀疑是不是头文件的问题。因为当我把一些#include "..."搬到#pragma once之前或者之后，错误报告就会发生变化。有时就只是说我的一个类重复定义了。</br>
</br>
以前用C写头文件的时候都是用宏定义来避免重复包含头文件。C++里虽然也还可用这个方法，但VC++就是不用，它用的是#pragma once。这一变化对我来说真是有点摸不着头脑了，我不清楚#pragma once的工作方式是如何的。而我现在遇到的问题又与这个有关。找找网上的内容看吧。上google搜了半天，那些论坛里的回答基本上都是“防止重复包含头文件的，你不用管他。”这样的。可是不管他真的行吗？我刚学的VC++，我看的书上是没有讲过这个内容的。怎么在网上也搜不到呢？经过我不懈的努力，终于让我找到了一篇http://www.yesky.com/127/1736627_3.shtml。</br>
</br>
作者Adding的这段话对我的帮助最大：“ 既然使用了包含文件，为什么还要在class CMainFrame前添加"class CViewerView;"等代码？如果用包含文件代替它，行不行？　　很多Visual C++书籍对这些问题避而不谈，但实际上这是一个重要的问题。如果不能理解上述代码，我们很可能为无法通过编译而大伤脑筋。这些问题的出现是基于这样的一些事实：在我们用标准C/C++设计程序时，有一个原则即两个代码文件不能相互包含，而且多次包含还会造成重复定义的错误。为了解决这个难题， Visual C++使用#pragma once来通知编译器在生成时只包含(打开)一次，也就是说，在第一次#include之后，编译器重新生成时不会再对这些包含文件进行包含(打开)和读取，因此我们看到在用向导创建的所有类的头文件中有#pragma once语句就不会觉得奇怪了。然而正是由于这个语句而造成了在第二次#include后编译器无法正确识别所引用的类。因此，我们在相互包含时还需要加入类似class CViewerView这样的语句来通知编译器这个类是一个实际的调用。 ”</br>
</br>
看来就是这个问题了。把我的代码一加上那些类的声明以后果然通过了编译。我感觉这个问题在VC++里面来说应该是值得注意的。可能是由于我刚学VC++，见识太少的原故吧。无论如何先记下来，说不定也有人在为这个#pragma once伤脑筋呢。
