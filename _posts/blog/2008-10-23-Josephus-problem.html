--- 
status: publish
layout: post
title: !binary |
  57qm55Gf5aSr6Zeu6aKY
tags: 
- ACM
- Algorithm
- Research
published: true
type: post
---
约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的人的序号为5，4，6，2，3。最后剩下1号。
假定在圈子里前K个为好人，后K个为坏人，你的任务是确定这样的最少M，使得所有的坏人在第一个好人之前被杀掉。
C++代码示例:
#include&lt;iostream&gt;
using namespace std;
void main()
{
int n,m,a[101],k,i,j,num; //计数器是从1开始的,所以100个人用101
cout&lt;&lt;"请输入参加游戏的玩家人数(不超过100人):";
cin&gt;&gt;n;
cout&lt;&lt;"----------------------------------------"&lt;&lt;endl;
if(n&gt;100)
{
cout&lt;&lt;"玩家太多,请重新登陆此程序!"&lt;&lt;endl;
return;
}
cout&lt;&lt;"输入游戏中要玩的数字:";
cin&gt;&gt;m;
cout&lt;&lt;"----------------------------------------"&lt;&lt;endl;
for(i=1;i&lt;=n;i++)
{
a【i】<em>=1;//注意百度百科里不让使用ASCII里的方括号，这里是中文字符集里的方括号，
</em> }
j=0;
k=0;
for(i=1;i&lt;=n;i++){
if(a【i】==1){
j=j+a【i】;
if(j==m)
{
j=0;
a【i】=0;
k++;
}
if(k==n){
num=i;
break;
}
}
if(i==n)
i=0;
}
cout&lt;&lt;"最后获胜的玩家是第 "&lt;&lt;num&lt;&lt;" 号玩家!"&lt;&lt;endl;
cout&lt;&lt;"----------------------------------------"&lt;&lt;endl;
}
Pascal代码示例：
program YSF;
var n,m,k,i,j,num:longint;
a:array[1..100] of longint;
begin
readln(n,m);
for i:=1 to n do
a:=1;
j:=0;
k:=0;
for i:=1 to n do
begin
if a=1 then
begin
j:=j+a;
if (j=m) then
begin
j:=0;
a:=0;
inc(k);
end;
if k=n then
begin
num:=i;
writeln(num);
halt;
end;
end;
if i=n then i:=0;
end;
writeln(num);
end.问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号
。

我们知道第一个人(编号一定是m%n-1) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开
始）:
k  k+1  k+2  ... n-2, n-1, 0, 1, 2, ... k-2
并且从k开始报0。

现在我们把他们的编号做一下转换：
k     --&gt; 0
k+1   --&gt; 1
k+2   --&gt; 2
...
...
k-2   --&gt; n-2
k-1   --&gt; n-1

变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根
据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x'
=(x+k)%n

如何知道(n-1)个人报数的问题的解？对，只要知道(n-2)个人的解就行了。(n-2)个人的解呢？当然是先求(n-3)的
情况 ---- 这显然就是一个倒推问题！好了，思路出来了，下面写递推公式：

令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]

递推公式
f[1]=0;
f[i]=(f[i-1]+m)%i;  (i&gt;1)

有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，
我们输出f[n]+1

由于是逐级递推，不需要保存每个f[i]，程序也是异常简单：

＃i nclude &lt;stdio.h&gt;

main()
{
int n, m, i, s=0;
printf ("N M = "); scanf("%d%d", &amp;n, &amp;m);
for (i=2; i&lt;=n; i++) s=(s+m)%i;
printf ("The winner is %d\n", s+1);
}

这个算法的时间复杂度为O(n)，相对于模拟算法已经有了很大的提高。算n，m等于一百万，一千万的情况不是问题
了。可见，适当地运用数学策略，不仅可以让编程变得简单，而且往往会成倍地提高算法执行效率。
