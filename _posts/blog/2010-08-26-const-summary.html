--- 
status: publish
layout: post
title: !binary |
  Qysr5LitY29uc3TmgLvnu5M=
tags: 
- c++
- const
- Technics
published: true
type: post
---
总结的比较好，需常看</br>
</br>
一、对于基本声明</br>
</br>
1.const int r=100; //标准const变量声明加初始化，因为默认内部连接所以必须被初始化，其作用域为此文件，编译器经过类型检查后直接用100在编译时替换。</br>
</br>
2.extend const int r=100; //将const改为外部连接，作用于扩大至全局，编译时会分配内存，并且可以不进行初始化，仅仅作为声明，编译器认为在程序其他地方进行了定义。</br>
</br>
3.const int r[ ]={1,2,3,4};</br>
</br>
struct S {int a,b;};</br>
</br>
const S s[ ]={(1,2),(3.4)}; //以上两种都是常量集合，编译器会为其分配内存，所以不能在编译期间使用其中的值，例如：int temp[r[2]];这样的编译器会报告不能找到常量表达式</br>
</br>
<!--more--></br>
</br>
二、对于指针</br>
</br>
1.const int *r=&amp;x; //声明r为一个指向常量的x的指针，r指向的对象不能被修改，但他可以指向任何地址的常量。</br>
</br>
2.int const *r=&amp;x; //与用法1完全等价，没有任何区别。</br>
</br>
3.int * const r=&amp;x; //声明r为一个常量指针，他指向x，r这个指针的指向不能被修改，但他指向的地址的内容可以修改。</br>
</br>
4.const int * const r=&amp;x; //综合1、3用法，r是一个指向常量的常量型指针。</br>
</br>
三、对于类型检查</br>
</br>
可以把一个非const对象赋给一个指向const的指针，因为有时候我们不想从这个指针来修改其对象的值；但是不可以把一个const对象赋值给一个非const指针，因为这样可能会通过这个指针改变指向对象的值，但也存在使这种操作通过的合法化写法，使用类型强制转换可以通过指针改变const对象：</br>
</br>
const int r=100;</br>
</br>
int * ptr = const_cast(&amp;r); //C++标准，C语言使用：int * ptr =(int*)&amp;r;</br>
</br>
四、对于字符数组</br>
</br>
如char * name = “china”; 这样的语句，在编译时是能够通过的，但是”china”是常量字符数组，任何想修改他的操作也能通过编译但会引起运行时错误，如果我们想修改字符数组的话就要使用char name[ ] = “china”; 这种形式。</br>
</br>
五、对于函数</br>
</br>
1.void Fuction1 ( const int r ); //此处为参数传递const值，意义是变量初值不能被函数改变</br>
</br>
2.const int Fuction1 (int); //此处返回const值，意思指返回的原函数里的变量的初值不能被修改，但是函数按值返回的这个变量被制成副本，能不能被修改就没有了意义，它可以被赋给任何的const或非const类型变量，完全不需要加上这个const关键字。但这只对于内部类型而言（因为内部类型返回的肯定是一个值，而不会返回一个变量，不会作为左值使用），对于用户自定义类型，返回值是常量是非常重要的，见下面条款3。</br>
</br>
3.Class CX; //内部有构造函数，声明如CX(int r =0)</br>
</br>
CX Fuction1 () { return CX(); }</br>
</br>
const CX Fuction2 () { return CX(); }</br>
</br>
如有上面的自定义类CX，和函数Fuction1()和Fuction2(),我们进行如下操作时：</br>
</br>
Fuction1() = CX(1); //没有问题，可以作为左值调用</br>
</br>
Fuction2() = CX(1); //编译错误，const返回值禁止作为左值调用。因为左值把返回值作为变量会修改其返回值，const声明禁止这种修改。</br>
</br>
4.函数中指针的const传递和返回：</br>
</br>
int F1 (const char * pstr); //作为传递的时候使用const修饰可以保证不会通过这个指针来修改传递参数的初值，这里在函数内部任何修改*pstr的企图都会引起编译错误。</br>
</br>
const char * F2 (); //意义是函数返回的指针指向的对象是一个const对象，它必须赋给一个同样是指向const对象的指针。</br>
</br>
const char * const F3(); //比上面多了一个const，这个const的意义只是在他被用作左值时有效，它表明了这个指针除了指向const对象外，它本身也不能被修改，所以就不能当作左值来处理。</br>
</br>
5.函数中引用的const传递：</br>
</br>
void F1 ( const X&amp; px); //这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的，他禁止对引用的对象的一切修改，唯一不同的是按值传递会先建立一个类对象的副本，然后传递过去，而它直接传递地址，所以这种传递比按值传递更有效。</br>
</br>
**另外只有引用的const传递可以传递一个临时对象，因为临时对象都是const属性，且是不可见的，他短时间存在一个局部域中，所以不能使用指针，只有引用的const传递能够捕捉到这个家伙。</br>
</br>
六、对于类</br>
</br>
1.首先，对于const的成员变量，只能在构造函数里使用初始化成员列表来初始化，试图在构造函数体内进行初始化const成员变量会引起编译错误。初始化成员列表形如：</br>
</br>
2.X:: X ( int ir ): r(ir) {} //假设r是类X的const成员变量</br>
</br>
2.const成员函数。提到这个概念首先要谈到const对象，正象内置类型能够定义const对象一样（const int r=10;），用户自定义类型也可以定义const对象(const X px(10);)，编译器要保证这个对象在其生命周期内不能够被改变。如果你定义了这样的一个const对象，那么对于这个对象的一切非const成员函数的调用，编译器为了保证对象的const特性，都会禁止并在编译期间报错。所以如果你想让你的成员函数能够在const对象上进行操作的话，就要把这个函数声明为const成员函数。假如f( )是类中的成员函数的话，它的声明形如：</br>
</br>
int f( ) const; //const放在函数的最后，编译器会对这个函数进行检查，在这个函数中的任何试图改变成员变量和调用非const成员函数的操作都被视为非法</br>
</br>
注意：类的构造和析构函数都不能是const函数。</br>
</br>
3.建立了一个const成员函数，但仍然想用这个函数改变对象内部的数据。这样的一个要求也会经常遇到，尤其是在一个苛刻的面试考官那里。首先我们要弄清楚考官的要求，因为有两种方法可以实现，如果这位考官要求不改变原来类的任何东西，只让你从当前这个const成员函数入手，那么你只有使用前面提到的类型强制转换方法。实例如下：</br>
</br>
//假如有一个叫做X的类，它有一个int成员变量r，我们需要通过一个const成员函数f( )来对这个r进行++r操作，代码如下</br>
</br>
void X::f( ) const</br>
</br>
{ (const_cast(this)) -&gt; ++r; } //通过this指针进行类型强制转换实现</br>
</br>
另外一种方法就是使用关键字：mutable。如果你的成员变量在定义时是这个样子的：</br>
</br>
mutable int r ;</br>
</br>
那么它就告诉编译器这个成员变量可以通过const成员函数改变。编译器就不会再理会对他的检查了。
